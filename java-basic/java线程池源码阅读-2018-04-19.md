最近对线程池的实现比较感心情，故对`TheadPoolExecutor`进行了分析阅读，对阅读中的知识点进行了整理记录，以做备忘。

### 概要

线程池对每个提交进来的任务及执行任务的线程进行管理，通常我们使用`Executors`工厂类的各个方法来创建线程池对象。

而该类主要有以下创建线程池的方法

1. newFixedThreadPool // 创建固定数量线程的线程池
2. newWorkStealingPool // 创建提供fork-join的并行处理池
3. newSingleThreadExecutor // 创建单一线程的线程池
4. newCachedThreadPool // 创建缓存的线程池，`最常用`
5. newSingleThreadScheduledExecutor // 创建单一线程的定时调度线程池
6. newScheduledThreadPool // 创建定时调度线程池

同时还有对默认线程工厂`DefaultThreadFactory`的实现

线程池主要解决一下两个问题：

1. 由于减少了每个任务的调用开销（主要是线程的创建和销毁，而这花费的时间可能比任务本身执行所花的时间更多），所以执行大量异步任务时可以提升性能；
2. 提供捆绑和管理各种资源，包括：线程和任务的执行、简单的统计和中断；

### 继承层次

- ThreadPoolExecutor [class]
  - AbstractExecutorService [class]
    - ExecutorService [Interface]
      - Executor [Interface]

#### Executor

该接口只有一个方法-`execute`，用于执行一个任务。它可能会抛出两种异常，当执行的任务为null时抛出空指针异常，当任务不被接受抛出拒绝执行异常。

```java
/**
 * Executes the given command at some time in the future.  The command
 * may execute in a new thread, in a pooled thread, or in the calling
 * thread, at the discretion of the {@code Executor} implementation.
 *
 * @param command the runnable task
 * @throws RejectedExecutionException if this task cannot be
 * accepted for execution
 * @throws NullPointerException if command is null
 */
void execute(Runnable command);
```

#### ExecutorService

该接口定义了两类操作，一类用于线程池生命周期的管控；一类用于对执行的命令进行重载。

生命周期管控

1. shutdown // 关闭线程池
2. shutdownNow // 立即关闭线程池
3. isShutdown // 是否关闭状态
4. isTerminated // 是否终止状态
5. awaitTermination // 在一段时间内等待线程池终止

执行命令的重载，主要是对Runnable和Caller进行请求参数抽象，以及Future对相应参数进行抽象。

1. <T> Future<T> submit(Callable<T> task);
2. <T> Future<T> submit(Runnable task, T result);
3. Future<?> submit(Runnable task);
4. <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
5. <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit);
6. <T> T invokeAny(Collection<? extends Callable<T>> tasks); // 只要有一个任务执行完成，则直接返回
7. <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit); // 带超时时间的处理

#### AbstractExecutorService

该类用于将重载的执行命令进行统一处理，将不变的内容抽象出来，并将变化的内容放置在当前方法中。
最终执行的方法只有一个-`void execute(Runnable command);`。

### ctl变量

线程池内部使用ctl原子变量的高低位来分别存储线程池的状态及有效的线程数。

```java
/**
 * 最重要的线程池控制状态，本身由integer的原子类对以下两类进行包装
 * workerCount, 有效的线程数
 * runState，运行，关闭，停止等状态
 *
 * The main pool control state, ctl, is an atomic integer packing
 * two conceptual fields
 *   workerCount, indicating the effective number of threads
 *   runState,    indicating whether running, shutting down etc
 *
 * In order to pack them into one int, we limit workerCount to
 * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2
 * billion) otherwise representable. If this is ever an issue in
 * the future, the variable can be changed to be an AtomicLong,
 * and the shift/mask constants below adjusted. But until the need
 * arises, this code is a bit faster and simpler using an int.
 *
 * The workerCount is the number of workers that have been
 * permitted to start and not permitted to stop.  The value may be
 * transiently different from the actual number of live threads,
 * for example when a ThreadFactory fails to create a thread when
 * asked, and when exiting threads are still performing
 * bookkeeping before terminating. The user-visible pool size is
 * reported as the current size of the workers set.
 *
 * The runState provides the main lifecycle control, taking on values:
 *
 *   RUNNING:  Accept new tasks and process queued tasks
 *   // 接受新任务并处理队列中的任务
 *
 *   SHUTDOWN: Don't accept new tasks, but process queued tasks
 *   // 不接受新任务，但是处理队列中的任务
 *   STOP:     Don't accept new tasks, don't process queued tasks,
 *             and interrupt in-progress tasks
 *   // 不接受新任务，不处理队里中的任务并终端正在执行的任务
 *
 *   TIDYING:  All tasks have terminated, workerCount is zero,
 *             the thread transitioning to state TIDYING
 *             will run the terminated() hook method
 *   // 所有任务已经终止了，线程数为0时自动过渡到整理中状态，将允许terminated()钩子方法
 *
 *   TERMINATED: terminated() has completed
 *   // 钩子方法terminated()被执行完毕
 *
 * The numerical order among these values matters, to allow
 * ordered comparisons. The runState monotonically increases over
 * time, but need not hit each state. The transitions are:
 *  // 线程池的这些状态是随着时间的演进会逐渐向上提升的，但并不是每个状态都会在某个时刻存在
 *
 * RUNNING -> SHUTDOWN
 *    On invocation of shutdown(), perhaps implicitly in finalize()
 * // shutdown()方法被调用，可能会隐式调用finalize()方法
 *
 * (RUNNING or SHUTDOWN) -> STOP
 *    On invocation of shutdownNow()
 * // shutdownNow()被调用
 *
 * SHUTDOWN -> TIDYING
 *    When both queue and pool are empty
 * // 队列和线程池都未空
 *
 * STOP -> TIDYING
 *    When pool is empty
 * // 线程为空
 *
 * TIDYING -> TERMINATED
 *    When the terminated() hook method has completed
 * // terminated()执行完成
 *
 * Threads waiting in awaitTermination() will return when the
 * state reaches TERMINATED.
 *
 * Detecting the transition from SHUTDOWN to TIDYING is less
 * straightforward than you'd like because the queue may become
 * empty after non-empty and vice versa during SHUTDOWN state, but
 * we can only terminate if, after seeing that it is empty, we see
 * that workerCount is 0 (which sometimes entails a recheck -- see
 * below).
 */
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

### ThreadPoolExecutor源码分析

1. ThreadPoolExecutor构造方法
2. execute方法
3. addWorker方法
4. Worker对象
5. runWorker方法
6. getTask方法
7. processWorkerExit方法
8. tryTerminate方法

### ThreadPoolExecutor生命周期

1. shutdown
2. shutdownNow
3. awaitTermination
4. 生命周期扩展点

### ThreadPoolExecutor拒绝策略